From 37e173855cc75881bc63e623928e316d9a09fc3e Mon Sep 17 00:00:00 2001
From: Josua Mayer <josua@solid-run.com>
Date: Sun, 18 Aug 2024 13:45:36 +0300
Subject: [PATCH 14/18] drm/panel: ronbo-rb070d30: support software-reset and
 optional gpios

Some board designs may not expose cpu control over the various control
gpios supported by this panel. Even without access to any control
signals, if the initial state is okay the panel may operate as expected.

Add a software-reset command in case reset-gpio is missing,
and convert all gpios to be optional.

Signed-off-by: Josua Mayer <josua@solid-run.com>
---
 drivers/gpu/drm/panel/panel-ronbo-rb070d30.c | 16 ++++++++++++----
 1 file changed, 12 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/panel/panel-ronbo-rb070d30.c b/drivers/gpu/drm/panel/panel-ronbo-rb070d30.c
index 535c8d1cc..fa5b0fedc 100644
--- a/drivers/gpu/drm/panel/panel-ronbo-rb070d30.c
+++ b/drivers/gpu/drm/panel/panel-ronbo-rb070d30.c
@@ -56,8 +56,16 @@ static int rb070d30_panel_prepare(struct drm_panel *panel)
 	msleep(20);
 	gpiod_set_value(ctx->gpios.power, 1);
 	msleep(20);
+
 	gpiod_set_value(ctx->gpios.reset, 1);
 	msleep(20);
+
+	if (!ctx->gpios.reset) {
+		dev_info(&ctx->dsi->dev, "soft-reset\n");
+		mipi_dsi_dcs_soft_reset(ctx->dsi);
+		msleep(120);
+	}
+
 	return 0;
 }
 
@@ -162,13 +170,13 @@ static int rb070d30_panel_dsi_probe(struct mipi_dsi_device *dsi)
 	drm_panel_init(&ctx->panel, &dsi->dev, &rb070d30_panel_funcs,
 		       DRM_MODE_CONNECTOR_DSI);
 
-	ctx->gpios.reset = devm_gpiod_get(&dsi->dev, "reset", GPIOD_OUT_LOW);
+	ctx->gpios.reset = devm_gpiod_get_optional(&dsi->dev, "reset", GPIOD_OUT_LOW);
 	if (IS_ERR(ctx->gpios.reset)) {
 		dev_err(&dsi->dev, "Couldn't get our reset GPIO\n");
 		return PTR_ERR(ctx->gpios.reset);
 	}
 
-	ctx->gpios.power = devm_gpiod_get(&dsi->dev, "power", GPIOD_OUT_LOW);
+	ctx->gpios.power = devm_gpiod_get_optional(&dsi->dev, "power", GPIOD_OUT_LOW);
 	if (IS_ERR(ctx->gpios.power)) {
 		dev_err(&dsi->dev, "Couldn't get our power GPIO\n");
 		return PTR_ERR(ctx->gpios.power);
@@ -178,7 +186,7 @@ static int rb070d30_panel_dsi_probe(struct mipi_dsi_device *dsi)
 	 * We don't change the state of that GPIO later on but we need
 	 * to force it into a low state.
 	 */
-	ctx->gpios.updn = devm_gpiod_get(&dsi->dev, "updn", GPIOD_OUT_LOW);
+	ctx->gpios.updn = devm_gpiod_get_optional(&dsi->dev, "updn", GPIOD_OUT_LOW);
 	if (IS_ERR(ctx->gpios.updn)) {
 		dev_err(&dsi->dev, "Couldn't get our updn GPIO\n");
 		return PTR_ERR(ctx->gpios.updn);
@@ -188,7 +196,7 @@ static int rb070d30_panel_dsi_probe(struct mipi_dsi_device *dsi)
 	 * We don't change the state of that GPIO later on but we need
 	 * to force it into a low state.
 	 */
-	ctx->gpios.shlr = devm_gpiod_get(&dsi->dev, "shlr", GPIOD_OUT_LOW);
+	ctx->gpios.shlr = devm_gpiod_get_optional(&dsi->dev, "shlr", GPIOD_OUT_LOW);
 	if (IS_ERR(ctx->gpios.shlr)) {
 		dev_err(&dsi->dev, "Couldn't get our shlr GPIO\n");
 		return PTR_ERR(ctx->gpios.shlr);
-- 
2.43.0

