From 2452856e3f572db09c4169ee7b12dc8058829336 Mon Sep 17 00:00:00 2001
From: Josua Mayer <josua@solid-run.com>
Date: Wed, 14 Aug 2024 14:06:44 +0300
Subject: [PATCH 17/18] panel driver

---
 drivers/gpu/drm/panel/Makefile                |   1 +
 .../drm/panel/panel-winstar-wj70n3tyjhmng0.c  | 318 ++++++++++++++++++
 2 files changed, 319 insertions(+)
 create mode 100644 drivers/gpu/drm/panel/panel-winstar-wj70n3tyjhmng0.c

diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 2ba560bca..2b7393c05 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -53,3 +53,4 @@ obj-$(CONFIG_DRM_PANEL_TPO_TPG110) += panel-tpo-tpg110.o
 obj-$(CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA) += panel-truly-nt35597.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_RM69299) += panel-visionox-rm69299.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
+obj-y += panel-winstar-wj70n3tyjhmng0.o
diff --git a/drivers/gpu/drm/panel/panel-winstar-wj70n3tyjhmng0.c b/drivers/gpu/drm/panel/panel-winstar-wj70n3tyjhmng0.c
new file mode 100644
index 000000000..31622337e
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-winstar-wj70n3tyjhmng0.c
@@ -0,0 +1,318 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Winstar WJ70N3TYJHMNG0 Panel Driver
+ */
+#include <drm/drm_crtc.h>
+#include <drm/drm_device.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+//#include <linux/of_platform.h>
+//#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <video/videomode.h>
+
+struct wj70n3tyjhmng0_panel {
+	struct drm_panel panel;
+	struct regulator *power_supply; // pins 2/3 VDD 1.8V for TFT
+	struct regulator *backlight_supply; // pins 31/32/33 VLED+ 12V for Backlight, for backlight driver
+	struct gpio_desc *reset_gpio; // pin 5 RESET
+	struct gpio_desc *standby_gpio; // pin 6 STBYB
+	struct gpio_desc *h_invert_gpio; // pin 28 L/R horizontal inversion
+	struct gpio_desc *v_invert_gpio; // pin 29 U/D vertical inversion
+	enum drm_panel_orientation orientation;
+};
+
+static inline struct wj70n3tyjhmng0_panel *to_wj70n3tyjhmng0_panel(struct drm_panel *panel)
+{
+	return container_of(panel, struct wj70n3tyjhmng0_panel, panel);
+}
+#if 0
+static const struct display_timing wj70n3tyjhmng0_timings = {
+	.pixelclock = { 40800000, 51200000, 51200000 },
+	.hactive = { 1024, 1024, 1024 },
+	.hfront_porch = { 16, 160, 160 },
+	.hback_porch = { 160, 160, 160 },
+	.hsync_len = { 1, 70, 140 },
+	.vactive = { 600, 600, 600 },
+	.vfront_porch = { 1, 12, 12 },
+	.vback_porch = { 23, 23, 23 },
+	.vsync_len = { 1, 20, 20 },
+};
+
+static int wj70n3tyjhmng0_panel_get_modes(struct drm_panel *panel,
+						   struct drm_connector *connector)
+{
+	struct wj70n3tyjhmng0_panel *priv = to_wj70n3tyjhmng0_panel(panel);
+	struct drm_display_mode *mode;
+	struct videomode vm;
+	static const u32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+
+	printk("wj70n3tyjhmng0_panel_get_modes\n");
+
+	videomode_from_timing(&wj70n3tyjhmng0_timings, &vm);
+	mode = drm_mode_create(connector->dev);
+	if (!mode) {
+		dev_err(panel->dev, "failed to add mode\n");
+		return 0;
+	}
+
+	drm_display_mode_from_videomode(&vm, mode);
+	mode->type |= DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.bpc = 8;
+	connector->display_info.width_mm = 154;
+	connector->display_info.height_mm = 86;
+	drm_display_info_set_bus_formats(&connector->display_info, &bus_format, 1);
+	drm_bus_flags_from_videomode(&vm, &connector->display_info.bus_flags);
+
+	drm_connector_set_panel_orientation(connector, priv->orientation);
+
+	return 1;
+}
+#else
+static const struct drm_display_mode default_mode = {
+	.clock		= 51206,
+	.hdisplay	= 1024,
+	.hsync_start	= 1024 + 160,
+	.hsync_end	= 1024 + 160 + 80,
+	.htotal		= 1024 + 160 + 80 + 80,
+	.vdisplay	= 600,
+	.vsync_start	= 600 + 12,
+	.vsync_end	= 600 + 12 + 10,
+	.vtotal		= 600 + 12 + 10 + 13,
+
+	.width_mm	= 154,
+	.height_mm	= 85,
+};
+
+static int wj70n3tyjhmng0_panel_get_modes(struct drm_panel *panel,
+				    struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+	static const u32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+
+	mode = drm_mode_duplicate(connector->dev, &default_mode);
+	if (!mode) {
+		dev_err(panel->dev, "Failed to add mode " DRM_MODE_FMT "\n",
+			DRM_MODE_ARG(&default_mode));
+		return -EINVAL;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.bpc = 8;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_display_info_set_bus_formats(&connector->display_info,
+					 &bus_format, 1);
+
+	return 1;
+}
+#endif
+
+#define dsi_generic_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static int wj70n3tyjhmng0_init_sequence(struct drm_panel *panel)
+{
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(panel->dev);
+
+	printk("wj70n3tyjhmng0_init_sequence\n");
+
+	/*
+	 * Init sequence was supplied by the panel vendor.
+	 */
+	//mipi_dsi_dcs_soft_reset(dsi);
+	dsi_generic_write_seq(dsi, 0x87, 0x5A);
+	dsi_generic_write_seq(dsi, 0xb0, 0x80);
+	dsi_generic_write_seq(dsi, 0xb1, 0x08);
+	dsi_generic_write_seq(dsi, 0xb2, 0x5A);
+	dsi_generic_write_seq(dsi, 0x80, 0x4b);
+	dsi_generic_write_seq(dsi, 0x81, 0xff);
+	dsi_generic_write_seq(dsi, 0x82, 0x1A);
+	dsi_generic_write_seq(dsi, 0x83, 0x88);
+	dsi_generic_write_seq(dsi, 0x84, 0x8f);
+	dsi_generic_write_seq(dsi, 0x85, 0x35);
+	dsi_generic_write_seq(dsi, 0x86, 0xb0);
+	mdelay(50);
+	mipi_dsi_dcs_exit_sleep_mode(dsi);
+	mdelay(120);
+	mipi_dsi_dcs_set_display_on(dsi);
+	mdelay(120);
+
+	dev_info(&dsi->dev, "Panel init sequence done\n");
+	return 0;
+}
+
+static int wj70n3tyjhmng0_panel_enable(struct drm_panel *panel)
+{
+	struct wj70n3tyjhmng0_panel *priv = to_wj70n3tyjhmng0_panel(panel);
+	int ret;
+
+	printk("wj70n3tyjhmng0_panel_prepare\n");
+
+	/* first enable power */
+	ret = regulator_enable(priv->power_supply);
+	if (ret)
+		dev_err(panel->dev, "failed to enable power supply\n");
+
+	/* deassert standby */
+	gpiod_set_value_cansleep(priv->standby_gpio, 0);
+	mdelay(20);
+
+	/* toggle reset high-low-high with 30ms delays */
+	gpiod_set_value_cansleep(priv->reset_gpio, 0);
+	mdelay(30);
+	gpiod_set_value_cansleep(priv->reset_gpio, 1);
+	mdelay(30);
+	gpiod_set_value_cansleep(priv->reset_gpio, 0);
+
+	mdelay(120);
+	// TODO: split into prepare and enable?
+	wj70n3tyjhmng0_init_sequence(panel);
+
+	printk("ret\n");
+	return ret;
+}
+
+static int wj70n3tyjhmng0_panel_disable(struct drm_panel *panel)
+{
+	struct wj70n3tyjhmng0_panel *priv = to_wj70n3tyjhmng0_panel(panel);
+
+	/* assert standby */
+	gpiod_set_value_cansleep(priv->standby_gpio, 1);
+
+	/* disable power */
+	regulator_disable(priv->power_supply);
+
+	/* assert reset */
+	gpiod_set_value_cansleep(priv->reset_gpio, 1);
+
+	return 0;
+}
+
+static const struct drm_panel_funcs wj70n3tyjhmng0_panel_funcs = {
+	.get_modes	= wj70n3tyjhmng0_panel_get_modes,
+	//.prepare	= wj70n3tyjhmng0_panel_prepare,
+	//.unprepare	= wj70n3tyjhmng0_panel_unprepare,
+	.enable		= wj70n3tyjhmng0_panel_enable,
+	.disable	= wj70n3tyjhmng0_panel_disable,
+};
+
+static int wj70n3tyjhmng0_panel_dsi_probe(struct mipi_dsi_device *dsi)
+{
+	struct wj70n3tyjhmng0_panel *priv;
+	int ret;
+
+	priv = devm_kzalloc(&dsi->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		printk("A\n");
+		return -ENOMEM;
+	}
+
+	priv->power_supply = devm_regulator_get_optional(&dsi->dev, "power");
+	if (IS_ERR(priv->power_supply)) {
+		if (PTR_ERR(priv->power_supply) != -ENODEV)
+			return PTR_ERR(priv->power_supply);
+
+		priv->power_supply = NULL;
+	}
+
+	/* assert reset by default */
+	priv->reset_gpio = devm_gpiod_get_optional(&dsi->dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(priv->reset_gpio))
+		return dev_err_probe(&dsi->dev, PTR_ERR(priv->reset_gpio),
+				     "failed to get reset gpio\n");
+
+	/* assert standby by default */
+	priv->standby_gpio = devm_gpiod_get_optional(&dsi->dev, "standby", GPIOD_OUT_HIGH);
+	if (IS_ERR(priv->standby_gpio))
+		return dev_err_probe(&dsi->dev, PTR_ERR(priv->standby_gpio),
+				     "failed to get standby gpio\n");
+
+	/* unused */
+	priv->h_invert_gpio = devm_gpiod_get_optional(&dsi->dev, "hinvert", GPIOD_ASIS);
+	if (IS_ERR(priv->h_invert_gpio))
+		return dev_err_probe(&dsi->dev, PTR_ERR(priv->h_invert_gpio),
+				     "failed to get hinvert gpio\n");
+
+	/* unused */
+	priv->v_invert_gpio = devm_gpiod_get_optional(&dsi->dev, "vinvert", GPIOD_ASIS);
+	if (IS_ERR(priv->v_invert_gpio))
+		return dev_err_probe(&dsi->dev, PTR_ERR(priv->v_invert_gpio),
+				     "failed to get vinvert gpio\n");
+
+	drm_panel_init(&priv->panel, &dsi->dev, &wj70n3tyjhmng0_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = of_drm_get_panel_orientation(dsi->dev.of_node, &priv->orientation);
+	if (ret)
+		return dev_err_probe(&dsi->dev, ret, "failed to get orientation\n");
+
+	/* probe backlight */
+	ret = drm_panel_of_backlight(&priv->panel);
+	if (ret)
+		dev_err_probe(&dsi->dev, ret, "failed to get backlight\n");
+
+	drm_panel_add(&priv->panel);
+
+	mipi_dsi_set_drvdata(dsi, priv);
+
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST | MIPI_DSI_MODE_LPM;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->lanes = 2;
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret) {
+		drm_panel_remove(&priv->panel);
+		return dev_err_probe(&dsi->dev, ret, "failed to attach dsi\n");
+	}
+
+	return ret;
+}
+
+static int wj70n3tyjhmng0_panel_dsi_remove(struct mipi_dsi_device *dsi)
+{
+	struct wj70n3tyjhmng0_panel *priv = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&priv->panel);
+	drm_panel_disable(&priv->panel);
+	drm_panel_unprepare(&priv->panel);
+
+	return 0;
+}
+
+
+static const struct of_device_id wj70n3tyjhmng0_panel_of_match[] = {
+	{ .compatible = "winstar,wj70n3tyjhmng0" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, wj70n3tyjhmng0_panel_of_match);
+
+static struct mipi_dsi_driver wj70n3tyjhmng0_panel_driver = {
+	.probe = wj70n3tyjhmng0_panel_dsi_probe,
+	.remove = wj70n3tyjhmng0_panel_dsi_remove,
+	.driver = {
+		.name = "panel-winstar-wj70n3tyjhmng0",
+		.of_match_table	= wj70n3tyjhmng0_panel_of_match,
+	},
+};
+module_mipi_dsi_driver(wj70n3tyjhmng0_panel_driver);
+
+MODULE_AUTHOR("Josua Mayer <josua@solid-run.com>");
+MODULE_DESCRIPTION("Winstar WJ70N3TYJHMNG0 Panel Driver");
+MODULE_LICENSE("GPL");
-- 
2.43.0

